type (
	// Interceptor allows intercepting requests.
	InterceptorFn func(req *http.Request, ctx context.Context) error

	// RequestEditorFn is the function signature for the RequestEditor callback function
	RequestEditorFn func(req *http.Request, ctx context.Context) error

	// RequestCompletionFn is the function signature for the RequestCompletion callback function
	RequestCompletionFn func(req *http.Request, resp *http.Response)

	// Client which conforms to the OpenAPI3 specification for this service.
	Client struct {
		// The endpoint of the server conforming to this interface, with scheme,
		// https://api.deepmap.com for example.
		Server string

		// HTTP client with any customized settings, such as certificate chains.
		Client *http.Client

		// A callback for modifying requests which are generated before sending over
		// the network.
		RequestEditor RequestEditorFn

		// A callback which gets called after request finished, before any
		// deserialization steps.
		RequestCompletion RequestCompletionFn

		// List of additional interceptors, which gets called prior
		// of the RequestEditor.
		Interceptors []InterceptorFn

		// userAgent to use
		userAgent string

		// timeout of single request
		requestTimeout time.Duration

		// timeout of idle http connections
		idleTimeout time.Duration

		// maxium idle connections of the underlying http-client.
		maxIdleConns int
	}

	// Option allows setting custom parameters during construction
	Option func(*Client) error
)

// NewClient creates a new Client.
func NewClient(ctx context.Context, opts ...Option) (*Client, error) {
	// create a client with sane default values
	client := Client{
		// must have a slash in order to resolve relative paths correctly.
		Server:         "",
		userAgent:      "oapi-codegen",
		maxIdleConns:   10,
		requestTimeout: 5 * time.Second,
		idleTimeout:    30 * time.Second,
	}
	// mutate defaultClient and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}

	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = client.newHTTPClient()
	}

	return &client, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) Option {
	return func(c *Client) error {
		if !strings.HasSuffix(baseURL, "/") {
			baseURL += "/"
		}
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// WithUserAgent allows setting the userAgent
func WithUserAgent(userAgent string) Option {
	return func(c *Client) error {
		c.userAgent = userAgent
		return nil
	}
}

// WithIdleTimeout overrides the timeout of idle connections.
func WithIdleTimeout(timeout time.Duration) Option {
	return func(c *Client) error {
		c.idleTimeout = timeout
		return nil
	}
}

// WithRequestTimeout overrides the timeout of individual requests.
func WithRequestTimeout(timeout time.Duration) Option {
	return func(c *Client) error {
		c.requestTimeout = timeout
		return nil
	}
}

// WithMaxIdleConnections overrides the amount of idle connections of the
// underlying http-client.
func WithMaxIdleConnections(maxIdleConns uint) Option {
	return func(c *Client) error {
		c.maxIdleConns = int(maxIdleConns)
		return nil
	}
}

// WithHTTPClient allows overriding the default httpClient, which is
// automatically created. This is useful for tests.
func WithHTTPClient(httpClient *http.Client) Option {
	return func(c *Client) error {
		c.Client = httpClient
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) Option {
	return func(c *Client) error {
		c.RequestEditor = fn
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestCompletionFn(fn RequestCompletionFn) Option {
	return func(c *Client) error {
		c.RequestCompletion = fn
		return nil
	}
}

// WithInterceptors allows adding 0..N interceptors, which get called in serial
// order prior of calling the RequestEditor before finally making the request.
// Use this function to attach authentication mechanisms.
func WithInterceptors(interceptors ...InterceptorFn) Option {
	return func(c *Client) error {
		c.Interceptors = interceptors
		return nil
	}
}

// newHTTPClient creates a httpClient for the current connection options.
func (c *Client) newHTTPClient() *http.Client {
	return &http.Client{
		Timeout: c.requestTimeout,
		Transport: &http.Transport{
			MaxIdleConns:    c.maxIdleConns,
			IdleConnTimeout: c.idleTimeout,
		},
	}
}

// Intercept intercepts the request, applies all registered Interceptors
// which are part of the client.
// If an Interceptor fails, the Interceptor chain will return early.
func (c *Client) Intercept(req *http.Request, ctx context.Context) error {
	for _, interceptor := range c.Interceptors {
		if err := interceptor(req, ctx); err != nil {
			return err
		}
	}
	return nil
}

// The interface specification for the client above.
type ClientInterface interface {

    // Intercept intercepts the request, applies all registered Interceptors
    // which are part of the client.
    // If an Interceptor fails, the Interceptor chain will return early.
    Intercept(req *http.Request, ctx context.Context) error

{{range . -}}
{{$hasParams := .RequiresParamObject -}}
{{$pathParams := .PathParams -}}
{{$opid := .OperationId -}}
    // {{$opid}} request {{if .HasBody}} with any body{{end}}
    {{$opid}}{{if .HasBody}}WithBody{{end}}(ctx context.Context{{genParamArgs $pathParams}}{{if $hasParams}}, params *{{$opid}}Params{{end}}{{if .HasBody}}, contentType string, body io.Reader{{end}}) (*http.Response, error)
{{range .Bodies}}
    {{$opid}}{{.Suffix}}(ctx context.Context{{genParamArgs $pathParams}}{{if $hasParams}}, params *{{$opid}}Params{{end}}, body {{$opid}}{{.NameTag}}RequestBody) (*http.Response, error)
{{end}}{{/* range .Bodies */}}
{{end}}{{/* range . $opid := .OperationId */}}
}


{{/* Generate client methods */}}
{{range . -}}
{{$hasParams := .RequiresParamObject -}}
{{$pathParams := .PathParams -}}
{{$opid := .OperationId -}}

func (c *Client) {{$opid}}{{if .HasBody}}WithBody{{end}}(ctx context.Context{{genParamArgs $pathParams}}{{if $hasParams}}, params *{{$opid}}Params{{end}}{{if .HasBody}}, contentType string, body io.Reader{{end}}) (*http.Response, error) {
    req, err := New{{$opid}}Request{{if .HasBody}}WithBody{{end}}(c.Server{{genParamNames .PathParams}}{{if $hasParams}}, params{{end}}{{if .HasBody}}, contentType, body{{end}})
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.Intercept(req, ctx); err != nil {
        return nil, err
    }
    if c.RequestEditor != nil {
        err = c.RequestEditor(req, ctx)
        if err != nil {
            return nil, err
        }
    }
    return c.Client.Do(req)
}

{{range .Bodies}}
func (c *Client) {{$opid}}{{.Suffix}}(ctx context.Context{{genParamArgs $pathParams}}{{if $hasParams}}, params *{{$opid}}Params{{end}}, body {{$opid}}{{.NameTag}}RequestBody) (*http.Response, error) {
    req, err := New{{$opid}}{{.Suffix}}Request(c.Server{{genParamNames $pathParams}}{{if $hasParams}}, params{{end}}, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.Intercept(req, ctx); err != nil {
        return nil, err
    }
    if c.RequestEditor != nil {
        err = c.RequestEditor(req, ctx)
        if err != nil {
            return nil, err
        }
    }
    return c.Client.Do(req)
}
{{end}}{{/* range .Bodies */}}
{{end}}

{{/* Generate request builders */}}
{{range .}}
{{$hasParams := .RequiresParamObject -}}
{{$pathParams := .PathParams -}}
{{$bodyRequired := .BodyRequired -}}
{{$opid := .OperationId -}}

{{range .Bodies}}
// New{{$opid}}Request{{.Suffix}} calls the generic {{$opid}} builder with {{.ContentType}} body
func New{{$opid}}Request{{.Suffix}}(server string{{genParamArgs $pathParams}}{{if $hasParams}}, params *{{$opid}}Params{{end}}, body {{$opid}}{{.NameTag}}RequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
    if err != nil {
        return nil, err
    }
    bodyReader = bytes.NewReader(buf)
    return New{{$opid}}RequestWithBody(server{{genParamNames $pathParams}}{{if $hasParams}}, params{{end}}, "{{.ContentType}}", bodyReader)
}
{{end}}

// New{{$opid}}Request{{if .HasBody}}WithBody{{end}} generates requests for {{$opid}}{{if .HasBody}} with any type of body{{end}}
func New{{$opid}}Request{{if .HasBody}}WithBody{{end}}(server string{{genParamArgs $pathParams}}{{if $hasParams}}, params *{{$opid}}Params{{end}}{{if .HasBody}}, contentType string, body io.Reader{{end}}) (*http.Request, error) {
    var err error
{{range $paramIdx, $param := .PathParams}}
    var pathParam{{$paramIdx}} string
    {{if .IsPassThrough}}
    pathParam{{$paramIdx}} = {{.ParamName}}
    {{end}}
    {{if .IsJson}}
    var pathParamBuf{{$paramIdx}} []byte
    pathParamBuf{{$paramIdx}}, err = json.Marshal({{.ParamName}})
    if err != nil {
        return nil, err
    }
    pathParam{{$paramIdx}} = string(pathParamBuf{{$paramIdx}})
    {{end}}
    {{if .IsStyled}}
    pathParam{{$paramIdx}}, err = runtime.StyleParam("{{.Style}}", {{.Explode}}, "{{.ParamName}}", {{.GoVariableName}})
    if err != nil {
        return nil, err
    }
    {{end}}
{{end}}
    queryUrl := fmt.Sprintf("%s{{genParamFmtString .Path}}", server{{range $paramIdx, $param := .PathParams}}, pathParam{{$paramIdx}}{{end}})
{{if .QueryParams}}
    var queryStrings []string
{{range $paramIdx, $param := .QueryParams}}
    var queryParam{{$paramIdx}} string
    {{if not .Required}} if params.{{.GoName}} != nil { {{end}}
    {{if .IsPassThrough}}
    queryParam{{$paramIdx}} = "{{.ParamName}}=" + {{if not .Required}}*{{end}}params.{{.GoName}}
    {{end}}
    {{if .IsJson}}
    var queryParamBuf{{$paramIdx}} []byte
    queryParamBuf{{$paramIdx}}, err = json.Marshal({{if not .Required}}*{{end}}params.{{.GoName}})
    if err != nil {
        return nil, err
    }
    queryParam{{$paramIdx}} = "{{.ParamName}}=" + string(queryParamBuf{{$paramIdx}})

    {{end}}
    {{if .IsStyled}}
    queryParam{{$paramIdx}}, err = runtime.StyleParam("{{.Style}}", {{.Explode}}, "{{.ParamName}}", {{if not .Required}}*{{end}}params.{{.GoName}})
    if err != nil {
        return nil, err
    }
    {{end}}
    queryStrings = append(queryStrings, queryParam{{$paramIdx}})
    {{if not .Required}}}{{end}}
{{end}}
    if len(queryStrings) != 0 {
        queryUrl += "?" + strings.Join(queryStrings, "&")
    }
{{end}}{{/* if .QueryParams */}}
    req, err := http.NewRequest("{{.Method}}", queryUrl, {{if .HasBody}}body{{else}}nil{{end}})
    if err != nil {
        return nil, err
    }

{{range $paramIdx, $param := .HeaderParams}}
    {{if not .Required}} if params.{{.GoName}} != nil { {{end}}
    var headerParam{{$paramIdx}} string
    {{if .IsPassThrough}}
    headerParam{{$paramIdx}} = {{if not .Required}}*{{end}}params.{{.GoName}}
    {{end}}
    {{if .IsJson}}
    var headerParamBuf{{$paramIdx}} []byte
    headerParamBuf{{$paramIdx}}, err = json.Marshal({{if not .Required}}*{{end}}params.{{.GoName}})
    if err != nil {
        return nil, err
    }
    headerParam{{$paramIdx}} = string(headerParamBuf{{$paramIdx}})
    {{end}}
    {{if .IsStyled}}
    headerParam{{$paramIdx}}, err = runtime.StyleParam("{{.Style}}", {{.Explode}}, "{{.ParamName}}", {{if not .Required}}*{{end}}params.{{.GoName}})
    if err != nil {
        return nil, err
    }
    {{end}}
    req.Header.Add("{{.ParamName}}", headerParam{{$paramIdx}})
    {{if not .Required}}}{{end}}
{{end}}

{{range $paramIdx, $param := .CookieParams}}
    {{if not .Required}} if params.{{.GoName}} != nil { {{end}}
    var cookieParam{{$paramIdx}} string
    {{if .IsPassThrough}}
    cookieParam{{$paramIdx}} = {{if not .Required}}*{{end}}params.{{.GoName}}
    {{end}}
    {{if .IsJson}}
    var cookieParamBuf{{$paramIdx}} []byte
    cookieParamBuf{{$paramIdx}}, err = json.Marshal({{if not .Required}}*{{end}}params.{{.GoName}})
    if err != nil {
        return nil, err
    }
    cookieParam{{$paramIdx}} = url.QueryEscape(string(cookieParamBuf{{$paramIdx}}))
    {{end}}
    {{if .IsStyled}}
    cookieParam{{$paramIdx}}, err = runtime.StyleParam("simple", {{.Explode}}, "{{.ParamName}}", {{if not .Required}}*{{end}}params.{{.GoName}})
    if err != nil {
        return nil, err
    }
    {{end}}
    cookie{{$paramIdx}} := &http.Cookie{
        Name:"{{.ParamName}}",
        Value:cookieParam{{$paramIdx}},
    }
    req.AddCookie(cookie{{$paramIdx}})
    {{if not .Required}}}{{end}}
{{end}}
    {{if .HasBody}}req.Header.Add("Content-Type", contentType){{end}}
    return req, nil
}

{{end}}{{/* Range */}}
